"""
This module simply converts .json generated by dload_dataset.py to mscoco .json
    format.

Since we do not know some information about the downloaded images (for example,
    year of creation, license), these cells are filled with the text "unknown".

For the brevity of the code the output json will have only one license:
    {
        'url': 'http://flickr.com/commons/usage/',
        'id': 7,
        'name':
        'No known copyright restrictions'
    }

/-----------------------------------------------------------------------------/

Template of source file (generated .json):

{
    "tsv_source_fname": < string >,
    "downloaded_flist": [
                            {
                                "cell_number": < int >,
                                "filename": < string >,
                                "caption": < string >
                            }, ...
                        ],
    "error_clist":  [ < int >, ... ]
}

/-----------------------------------------------------------------------------/

Template of destination file (MSCOCO .json standard):

{
    "info": {
        "description": "This is stable 1.0 version..",
        "url": "http://mscoco.org",
        "version": "1.0",
        "year": 2017,
        "contributor": "Microsoft COCO.group",
        "date_created": "2017-01-27 09:11:52.357474",
    "images": [
            {
                "licence": < int >,
                "file_name": < filename.jpg >,
                "coco_url": "http://mscoco.org/images/391895",
                "height": 360,
                "width": 640,
                "date_captured": "2017-11-14 11:18:45",
                "flick_url": < url >,
                "id": 391895
            }, { ... }, ...
        ],
    "licenses": [
            {
                "url": "http:// ... .com"
                "id": 1,
                "name": 'Attribution-NonCommercial-ShareAlike Licence'
            }, { ... }, ...
        ],
    "annotations": [
            {
                "image_id": 203564,
                "id": 37,
                "caption": "A bicycle replica with a clock as the front wheel."
            }, { ... }, ...
        ]
    }
}

/-----------------------------------------------------------------------------/

"""

import os
import sys
import cv2
import json
import argparse
import datetime

# this is example of mscoco json file that will be copied for filling with data
_example_mscoco_dict = {
    'info': {
        'description': 'This is custom dataset.',
        'url': 'unknown',
        'version': 'unknown',
        'year': 'unknown',
        'contributor': 'unknown',
        'date_created': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        },
    'images': [],
    'licenses': [
            {
                'url': 'http://flickr.com/commons/usage/',
                'id': 7,
                'name':
                'No known copyright restrictions'
            }
        ],
    'annotations': []
}

def _a_parse():
    """
    This function is a simple argument parser. Checks if paths in arguments are
        right & checks if directories exist.

    Return:
    < dict > -- {
                'source_json': < string >,
                'output_json': < string >,
                'images_dir': < string >
                }

    """
    a_parser = argparse.ArgumentParser()
    a_parser.add_argument(
                '-s',
                '--source_json',
                metavar='/path/to/json',
                required=True,
                help='path to source json-file')
    a_parser.add_argument(
                '-o',
                '--output_json',
                metavar='/path/to/json',
                default='generated_mscoco.json',
                required=False,
                help='path to destination json-file')
    a_parser.add_argument(
                '-i',
                '--images_dir',
                metavar='/path/to/images/directory',
                required=False,
                help='path to images directory. If not specified height &' + \
                        ' width of images will be null'
    )

    args = vars(a_parser.parse_args())
    source_json = os.path.abspath(args.get('source_json'))
    output_json = os.path.abspath(args.get('output_json'))
    images_dir = args.get('images_dir')

    if os.path.splitext(source_json)[1] != '.json':
        print('\n[ERROR]: source .json file has wrong extension')
        sys.exit(1)

    if os.path.splitext(output_json)[1] != '.json':
        print('\n[ERROR]: output .json file has wrong extension')
        sys.exit(1)

    if os.path.exists(source_json) != True:
        print('\n[ERROR]: source .json file has not found')
        sys.exit(1)

    if os.path.exists(output_json):
        ans = input('\n[ATTENTION]: output .json file already exist, ' + \
                                                    'overwrite it? [Y/n]: ')
        print(ans)
        if ans in {'True', 'true', '1', 't', 'y', 'yes', ''}:
            print('File will be overwritten.')
        else:
            print('Exiting..')
            sys.exit(1)


    if images_dir is not None:
        images_dir = os.path.abspath(images_dir)

        if os.path.isdir(images_dir) != True:
            print('[ERROR]: images_dir is not a directory')
            sys.exit(1)
        if os.path.exists(images_dir) != True:
            print('[ERROR]: images_dir does not exist')
            sys.exit(1)
        print('Images  checked successfully. Height & width will be recorded.')
    else:
        print('[ATTENTION]: images_dir is not specified. Height & width will' +\
            ' not be recorded.')

    args.update({
            'source_json': source_json,
            'output_json': output_json,
            'images_dir': images_dir
            })

    return args

def convert_raw2mscoco(source_json_path, output_json_path, images_dir):
    """
    This function converts .json generated by dload_dataset.py to mscoco .json
        format. It is understood that the json files have the desired format
        specified in the module description (there are no checks for right keys
        in dictionaries).
    If images_dir is not specified then cells 'height' and 'width' will be
        filled with None. Otherwise it will open each image to record it shape.
    In that case if there will be any trouble then it will skip image with its
        annotation.
    In any case if filename or caption of the image is None then it will be
        skipped.

    Keyword arguments:
    source_json_path -- path to source .json file that will be converted
    output_json_path -- path to destination .json file

    """
    with open(source_json_path, 'r') as json_file:
        s_json_data = json.load(json_file)

    o_json_data = _example_mscoco_dict.copy()

    # images & annotations lists that will be updated in o_json_data
    images_list = []
    annotations_list = []

    images_id_count = 0
    annotations_id_count = 0

    # if images_dir is none then height & width cells will be None
    if images_dir is None:
        for flist_element in s_json_data.get('downloaded_flist'):
            current_filename = flist_element.get('filename')
            current_annotation = flist_element.get('caption')

            if current_filename is None or current_annotation is None:
                print('[ATTENTION]: file: "{}" with caption: "{}"' + \
                    ' was skipped'.format(current_filename, current_annotation))
                continue

            images_element = {
                'licence': 7,
                'file_name': current_filename,
                'coco_url': 'unknown',
                'height': None,
                'width': None,
                'date_captured': 'unknown',
                'flick_url': 'unknown',
                'id': images_id_count
            }

            annotations_element = {
                'image_id': images_id_count,
                'id': annotations_id_count,
                'caption': current_annotation
            }

            images_list.append(images_element)
            annotations_list.append(annotations_element)

            images_id_count += 1
            annotations_id_count += 1

    # if it won't be able to open image then element will be skipped
    else:
        for flist_element in s_json_data.get('downloaded_flist'):
            current_filename = flist_element.get('filename')
            current_annotation = flist_element.get('caption')

            if current_filename is None or current_annotation is None:
                print(('[ATTENTION]: file "{}" with caption: "{}"' + \
                    ' was skipped').format(current_filename, current_annotation))
                continue

            image_np = cv2.imread(os.path.join(images_dir, current_filename))
            if image_np is None:
                print(('[ATTENTION]: file "{}" has not found and was' + \
                    ' skipped').format(current_filename))
                continue

            images_element = {
                'licence': 7,
                'file_name': current_filename,
                'coco_url': 'unknown',
                'height': image_np.shape[0],
                'width': image_np.shape[1],
                'date_captured': 'unknown',
                'flick_url': 'unknown',
                'id': images_id_count
            }

            annotations_element = {
                'image_id': images_id_count,
                'id': annotations_id_count,
                'caption': current_annotation
            }

            images_list.append(images_element)
            annotations_list.append(annotations_element)

            images_id_count += 1
            annotations_id_count += 1

    o_json_data.update({'images': images_list, 'annotations': annotations_list})

    with open(output_json_path, 'w') as json_file:
        json.dump(o_json_data, json_file)

if __name__ == "__main__":

    args = _a_parse()
    convert_raw2mscoco(
            args.get('source_json'),
            args.get('output_json'),
            args.get('images_dir')
            )
